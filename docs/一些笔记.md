## gamma矫正

部分人认为是由于早期 CRT 显示器的问题，即输出的亮度和输入的电压并非线性关系，而是近似 2.2 次幂的关系，导致进入人眼的亮度要比计算机上存储的亮度要低。例如，计算机上存储的亮度为 0.5，经过显示器调整后变为 0.5 的 2.2 次幂，即 0.218。为了让进入人眼的亮度与计算机中存储的值相同，需要在显示器调整前将亮度变为自身的 1/2.2 次幂，即 0.73，这样在经过显示器的调整，进入人眼就是 0.5 了，也就是说，Gamma 校正可以补偿由于显示器造成的亮度下降。这里需要注意的是，2.2 这个值是一个近似值，或者可以说是一个标准，实际上可能会有不同，现在的显示器甚至可以调节。
https://zhuanlan.zhihu.com/p/36581276

一般真实渲染最后一步是要做gamma矫正的，有些引擎不注重真实渲染的话，就不做了。

### SRGB与线性空间

https://zhuanlan.zhihu.com/p/66558476

### 关于shadowMap中的自遮挡问题

最简单的shadowMap结果出来的画面锯齿很明显，是因为深度纹理的一个个深度是离散的，第二次pass时多个片元虽然深度不同，但都会对于同一个深度纹理中的纹素，当视角倾斜时，效果尤为明显，显示出一条一条的锯齿。
在第一次pass中对所有的顶点的z值加上bias偏移量，使得深度纹理往后推，这样第二次比较的时候就容易比之前深度小，所有避免了锯齿的发生。但是这个bias如果移的很大，就会发生peterpan的现象。
只是添加bias仍然不能解决另外一些场景，如正对着灯光的球体，球体两边是有锯齿的。这时候应该有个按法线和光线方向的bias计算，使得第一次pass中的各个顶点的xyz按法线方向收缩，可以想象，球体对两侧进行收缩，两侧空出来的区域深度会显著加大，这也就让原有的两侧在渲染时深度明显小于SM上的深度，从而处于光照之下。

### sampler2DShadow

要使用 sampler2DShadow，需要做两件事。第一，需要开启比较模式，否则会行为未定义。有 sampler 或者 texture 属性 GL_TEXTURE_COMPARE_MODE = GL_COMPARE_REF_TO_TEXTURE，还需要设定比较方式，与深度测试设置参数方法相同。第二，texture 函数采样输入值为三维变量，前面两个值与纹理坐标无异，第三个坐标为待比较的深度值。
对 sampler2DShadow 使用 texture 后返回的值在 0.0 和 1.0 之间。如果设定的采样滤波为 nearest，则比较测试通过返回 1.0，否则返回 0.0；如果设定的采样滤波为 linear，则会选取采样点最近的四个像素，分别进行深度比较，可能返回 0.0、0.25、0.50、0.75、1.0 等值，表示通过测试和总像素数的比值。
其实使用线性滤波时， sampler2DShadow 比通常的 sampler2D 可以达到更好的抗锯齿效果。因为，sampler2DShadow 表示四个点的比值，而 sampler2D 只能得到一个单一的平均深度和一个布尔型，这对阴影锯齿来说并不理想。

### PCF
个人理解PCF核心在于平均化，不再是传统与深度图比较产生的true和false。例如，使用sampler2DShadow加上线性纹理过滤，会与4个点进行比较，返回0-1之间的插值（4个中有几个通过？）

深度纹理什么时候用颜色缓冲区？什么时候用深度缓冲？需要自己比较的时候用颜色缓冲，GPU硬件比较返回值的时候用深度缓冲，如sampler2DShadow类型

### 基于高斯卷积的PCF
基于sampler2DShadow的双线性插值采样，实际一个采样点考虑到了周围四个点，因此，基于高斯卷积核重新计算各个采样点的偏移量以及对应的权重值，构建一个新的卷积核。
0 0 0 0 0 0 0
0 1 3 4 3 1 0
0 3 9 12 9 3 0
0 4 12 16 12 4 0    
0 3 9 12 9 3 0
0 1 3 4 3 1 0
0 0 0 0 0 0 0
该5*5的卷积核，如根据采样点的偏移量算出左上角 0 0 的权重k，该k值是这四个点的线性插值。
                                         0 1                                                                                                       
                                                                         
0 0 0 
0 1 3 
0 3 9  算出四个k后，则计算uv的具体偏移量和对应权重值。

对应公式：
 (k[x, y] == (1 - u) (1 - v) w)
 (k[x + 1, y] == u (1 - v)*w)
 (k[x, y + 1] == (1 - u) v*w)
 (k[x + 1, y + 1] == u*v*w)

![Alt text](images/%E5%AF%B9%E4%BA%8E%E9%AB%98%E6%96%AF%E5%8D%B7%E7%A7%AFPCF%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%9B%BE.png)


### CSM
1. 相机视锥体分割
2. 对分割后的视锥体求取包围盒
3. 由包围盒计算灯光的左右、上下、前后两个面，从而计算灯光正交投影矩阵
4. ShadowMap渲染
5. 级联选择

传统计算包围盒是计算视锥体最紧的矩形包围盒，该包围盒的计算方法优点是贴图利用率高，视锥体填满了整个深度贴图，但是缺点是随着视锥体或者灯光移动，近平面的大小会发生改变，因此深度贴图的
分辨率也会发生改变，产生阴影闪屏（swimm）的现象。
为了改善此现象，引入了stabilize CSM。
对于视锥体的旋转：采用了计算视锥体包围球的计算方式，当视锥体或者灯光怎么转时，球的大小是不变的，因此贴图分辨率不变。包围球的计算可以使用简单的求出中心点，算最大半径的方式。也可以使用能得到更加紧凑边界的标准算法。
对于视锥体的平移：采用偏移投影矩阵，保证相机移动前和移动后，世界空间中的同一点都能投影到相同纹理贴图上。

注意：CSM只适用于平行光

### 数组纹理与离屏渲染连接

gl.createFrameBuffer()
gl.bindFrameBuffer(gl.FRAMEBUFFER, fbo)

gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D_ARRAY, colorTexture);
gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, width, height, layers, border, gl.RGBA, type, null);
gl.texParameteri(gl.TEXTURE_2D_ARRAY,...)

gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D_ARRAY, depthTexture);
gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.DEPTH_COMPONENT,, width, height, layers, border, gl.DEPTH_COMPONENT,, type, null);
gl.texParameteri(gl.TEXTURE_2D_ARRAY,...)

gl.bindFrameBuffer(gl.FRAMEBUFFER, fbo)
for(let i =0; i<layers,i++){
gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorTexture, 0, i)
gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthTexture, 0, i)
gl.clear(depth,color);
render()...
}

